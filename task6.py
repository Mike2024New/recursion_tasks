"""задача: поиск элемента в списке"""


def contains(collection: object, value: object, dict_value=False) -> bool:
    """
    Проверка наличия элемента в коллекции
    :param collection: список с элементами
    :param dict_value: опциональный параметр, указывать только в случае словаря, искать в ключах или в значениях
    :param value: искомый элемент, любой тип данных
    :return: True если элемент содержится в коллекции, False если элемент не содерж в коллекции
    =========================================================
    Пример вызова функции:
    1.
    res = contains(collection=[1, 2, 3, 4, 5], value=3)
    В переменную res запишется True, так как 3 содержится в коллекции collection
    2.
    res = contains(collection={"1": "a", "2": "b"}, value="b", dict_value=True) # поиск в значениях словаря
    в переменную запишется True, так как b есть в значениях словаря
    3.
    res = contains(collection={"1": "a", "2": "b"}, value="b", dict_value=False) # поиск в ключах словаря
    в переменную запишется True, так как b отсутствует в ключах словаря
    =========================================================
    !Данная функция хорошо подходит только для коротких списков (не более 900 элементов, в зависимости от пк и системы),
    это обусловлено ограничениями рекурсивных функций, если превысить лимит то будет переполнение стека и выброс
    исключения.
    !! Эта функция написана для понимания как работает рекурсия, для серьёзной работы лучше рассмотреть функцию с
    итеративными решениями. Возможно стоит подумать о многопоточности (или asyncio) для кластеризации программы на
    псевдопараллельный режим, что ускорит поиски.
    ==========================================================
    ОБРАБАТЫВАЕМЫЕ ИСКЛЮЧЕНИЯ:
    ValueError:
        -Длина элементов больше 900
    TypeError:
        -Тип входных данных не является одним из типов: set,list,dict,tuple
    ==========================================================
    ЕСЛИ В ФУНКЦИЮ ПЕРЕДАНЫ МНОЖЕСТВО ИЛИ СЛОВАРЬ ТО ОНИ ПРЕОБРАЗУЮТСЯ В СПИСОК, СЛОВАРЬ ПРЕОБРАЗОВЫВАЕТСЯ В СПИСОК
    КЛЮЧЕЙ ИЛИ ЗНАЧЕНИЙ В ЗАВИСИМОСТИ ОТ ПАРАМЕТРА
    """
    if not isinstance(collection, (set, list, dict, tuple)):  # проверяем типы
        raise TypeError(
            f"Ошибка входных данных, поддерживаются типы коллекции set, list, dict, tuple, передано {type(collection)}")
    if isinstance(collection, set):  # преобразование из множества в список
        collection = list(collection)
    if isinstance(collection, dict):  # преобразование из словаря в список ключей или значений (если dict_value = True)
        collection = list(collection.values()) if dict_value else list(collection.keys())
        print(collection)
    if len(collection) > 900:
        """нужно помнить про ограничения стека вызовов рекурсии (на моем ПК это 992), на других может быть и другое
        всё зависит от ресурсов конкретного ПК"""
        raise ValueError(f"Эта функция может обработать не более 900 элементов. Передано {len(collection)}")
    if not collection:  # БАЗОВЫЙ СЛУЧАЙ выход из рекурсии, все элементы просмотрены / искомый элемент не найден
        return False
    if collection[-1] == value:  # БАЗОВЫЙ СЛУЧАЙ если последний элемент списка совпал с искомым значением то True
        return True
    return contains(collection[:-1], value)  # РЕКУРСИВНЫЙ СЛУЧАЙ |-> СПУСК В ГЛУБЬ РЕКУРСИИ


"""
СТЕК ВЫЗОВОВ:
    Пример 1. негативный случай (False):
    входные данные: collection = [1,2,3,4,5], value = 0
    Спуск:
    contains(collection=[1,2,3,4,5],value=3)
        contains(collection=[1,2,3,4],value=3)
            contains(collection=[1,2,3],value=3)
                contains(collection=[1,2],value=3)
                    contains(collection=[1],value=3)
                        contains(collection=[],value=3) |-> базовый случай длина списка равна 0
                        Подъем (обратный стек вызовов:
                        return False
                    return False
                return False
            return False
        return False
    return False


    Пример 2. позитивный случай (True):

    входные данные: collection = [1,2,3,4,5], value = 3
    Спуск:
    contains(collection=[1,2,3,4,5],value=3)
        contains(collection=[1,2,3,4],value=3)
            contains(collection=[1,2,3],value=3) |-> базовый случай, последний элемент списка равен value        
            Подъем (обратный стек вызовов):
            return True
        return True
    return True

    Идея заключается в следующем, уменьшаем список на 1 элемент на каждый стек вызовов, и выполняем проверку значения
    и последнего элемента списка если элемент списка совпал с искомым (проверяемым элементом), возвращаем True. 
    Если же стек вызовов дошел до ситуации когда список пустой, то возвращаем False, так как все элементы проверены и 
    искомого элемента в ней не нашли.

"""

if __name__ == '__main__':
    res = contains(collection={"1": "a", "2": "b"}, value="b", dict_value=True)
    print(res)
