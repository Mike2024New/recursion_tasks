"""
поиск наибольшего общего делителя (НОД)
Решение 1 поиск через алгоритм Евклида
"""


def find_devider(a: int, b: int) -> int:
    """
    Поиск наибольшего общего делителя через алгоритм Евклида
    :param a: натуральное число
    :param b: натуральное число
    :return: НОД(a,b)
    если a<b, то a и b меняются местами, так как функция делит большее число на меньшее
    =========================================
    Пример использования:
        find_devider(28, 14) # вернет 4
        find_devider(0,10) # вернет 10 (то есть само же число)
        find_devider(28,-14) # вызовет ValueError
        find_devider(28, 0) # вызовет ZeroDivisionError
    =========================================
    Обрабатываемые исключения:
    ValueError:
        -одно из чисел a или b является отрицательным.
    ZeroDivisionError:
        -делитель не может быть нулём
    """
    if a < 0 or b < 0:
        raise ValueError("алгоритм Евклида работает только с натуральными (положительными) числами.")
    if b > a != 0:  # если b>a выполнить разворот a и b
        a, b = (b, a)
    if b == 0:
        raise ZeroDivisionError("делить на ноль, могут только монахи математики шестого дана с чёрным поясом!")
    if a % b == 0:  # |-> базовый случай a поделилось на b без остатка
        return b

    return find_devider(b, a % b)  # |-> рекурсивный случай


res = find_devider(28, 36)
print(res)

"""
СТЕК ВЫЗОВОВ:
    Решение через алгоритм Евклида
    для тестового значения find_devider(a=64,b=28)
    find_devider(a=64,b=28)
        find_devider(a=28,b=8)
            find_devider(a=8,b=4) |-> базовый случай / a делится на b без остатка
            return 4 |-> возвращаем тот делитель, на который a делится без остатка
        return 4
    return 4
    
    В основе решения этой задачи, стоит алгоритм Евклида. Большее число делится на меньшее, до тех пор пока не поделится
    без остатка, после того как остаток будет равен 0, возвращаем делитель.
    При каждом рекурсивном вызове в a передаём b, b=a/b.
"""
